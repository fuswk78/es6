    for(var i=0;i<10;i++) {}
    let:
        作用：  用来声明变量
        作用域：只在let命令所在的代码块内有效
                不存在变量提升，一定要先声明再使用
        
        暂时性死区：
            在代码块内，使用let声明之前，该变量不可用
            typeOf()操作变得不安全
            let声明之前typeOf检测此变量，报RefereenceError错误
            
    
        demo1
            var 可在代码块外获取，
            let 声明的a变量的获取会报错
        
        demo2
            for循环适合使用let变量
            i变量只在for循环内有效
            var声明的i，每一次循环，新的i值会覆盖原来的值，let声明变量就能解决此问题
                for(let i=0; i<10; i++) {
                    a[i] = function() {
                        console.log(i);
                    }
                }
            执行a[6]()，输出6; var声明i变量，执行输出结果为10;
        
        demo3
            不允许在相同作用域重复声明一个变量
            不能在函数内部重新声明参数
        
        demo4
            生成块级别作用域，外层作用域无法读取内层作用域的变量
            里层let n = 10 不会影响到外层n变量
        
        demo5
            块级作用域内的函数声明
            ES5：函数只能在定层作用域和函数作用域之中声明（不能块级内声明），严格模式下报错
            ES6，允许在块级作用域声明函数,且块级作用域之外不可引用
                if(true) {
                    function f() {}
                }
            但是建议：避免在块级作用域内声明函数，若必须写成函数表达式
        
    
    const
        作用：  声明只读变量
                声明，常量值不能改变
                只声明不赋值会报错，一旦声明，需立即被初始化，不能留到以后进行赋值。
        作用域：块级作用域内
                变量不提升，存在暂时性死区
                不可重复声明
        声明符合类型变量
            变量名指向数据所在地址，保证变量名指向地址不变，地址数据可变
            
        冻结对象：Object.freeze
            冻结对象时，对象的属性也应进行冻结
            冻结函数见代码示例：constantize变量
            
    ES6开始，全局变量将逐渐与全局对象的属性脱钩   

    自ES6后，声明变量有6种：
        var; function; let; const; import; class
        
    
        
        
        